```plain
将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象
```



建造者模式使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。



使用多个简单的对象一步一步构建成一个复杂的对象，有点像造房子一样一步步从地基做起到万丈高楼。



#### 介绍



**意图：**将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。



**主要解决：**主要解决在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。



**何时使用：**一些基本部件不会变，而其组合经常变化的时候。



**如何解决：**将变与不变分离开。



**关键代码：**建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。



**应用实例：** 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"。 2、JAVA 中的 StringBuilder。



StringBuilder

StringBuffer

Spring里的BeanDefinitionBuilder

Mybatis里的SqlSessionFactoryBuilder



**优点：** 1、建造者独立，易扩展。 2、便于控制细节风险。



**缺点：** 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。



**使用场景：** 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。



**优点**



1. 产品的建造和表示分离，实现了解耦。使用建造者模式可以使客户端不必知道产品内部组成的细节。
2. 将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰
3. 具体的建造者类之间是相互独立的，这有利于系统的扩展。增加新的具体建造者无需修改原有类库的代码，符合“开闭原则“。具体的建造者相互独立，因此可以对建造的过程逐步细化，而不会对其他模块产生任何影响。



**缺点**



1. 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似；如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。
2. 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。



**应用场景**



1. 需要生成的产品对象有复杂的内部结构，这些产品对象具备共性；
2. 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。
3. 需要生成的对象内部属性本身相互依赖。
4. 适合于一个具有较多的零件（属性）的产品（对象）的创建过程。



#### 建造者与抽象工厂模式的比较



- 与抽象工厂模式相比，建造者模式返回一个组装好的完整产品，而抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族 。
- 在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象 。
- 如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车！
- 与工厂模式的区别是：建造者模式更加关注与零件装配的顺序，一般用来创建更为复杂的对象!



#### 概念



1. 定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示！
2. 主要作用：在用户不知道 对象的建造过程和细节 的情况下就可以直接创建复杂的对象。
3. 如何使用：用户只需要给出指定复杂对象的类型和内容，建造者模式负责按顺序创建复杂对象（把内部的建造过程和细节隐藏起来）
4. 解决的问题：

- - 方便用户创建复杂的对象（不需要知道实现过程）
  - 代码复用性 & 封装性（将对象构建过程和细节进行封装 & 复用）



#### 角色分析



[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-GOhiGMIj-1608519950048)(https://blog.kuangstudy.com/usr/uploads/2019/10/1982559383.png)]



- 指挥者（Director）直接和客户（Client）进行需求沟通；
- 沟通后指挥者将客户创建产品的需求划分为各个部件的建造请求（Builder）；
- 将各个部件的建造请求委派到具体的建造者（ConcreteBuilder）；
- 各个具体建造者负责进行产品部件的构建；
- 最终构建成具体产品（Product）。



#### 方式一



通过Client、Director、Builder和Product形成的建造者模式！



**角色分析：**



1. 抽象建造者（builder）：描述具体建造者的公共接口，一般用来定义建造细节的方法，并不涉及具体的对象部件的创建。
2. 具体建造者（ConcreteBuilder）：描述具体建造者，并实现抽象建造者公共接口。
3. 指挥者（Director）：调用具体建造者来创建复杂对象（产品）的各个部分，并按照一定顺序（流程）来建造复杂对象。
4. 产品（Product）：描述一个由一系列部件组成较为复杂的对象。



既然是建造者模式，那么我们还是继续造房吧，其实我也想不到更简单的例子。假设造房简化为如下步骤：（1）地基（2）钢筋工程（3）铺电线（4）粉刷 ； “如果”要盖一座房子，首先要找一个建筑公司或工程承包商（指挥者）。承包商指挥工人（具体建造者）过来造房子（产品），最后验收。步骤抽象如下：



1. 创建抽象建造者定义造房步骤
2. 创建工人具体实现造房步骤
3. 创建承包商指挥工人施工
4. 验收，检查是否建造完成



上面示例是 Builder模式的常规用法，导演类 Director 在 Builder模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类，但是有些情况下需要简化系统结构，可以把Director和抽象建造者进行结合。



#### 方式二



通过静态内部类方式实现零件无序装配化构造，这种方式使用更加灵活，更符合定义。内部有复杂对象的默认实现，使用时可以根据用户需求自由定义更改内容，并且无需改变具体的构造方式。就可以生产出不同复杂产品



**角色分析**



1. 抽象建造者
2. 具体建造者
3. 产品



比第一种方式少了指挥者，主要是因为第二种方式把指挥者交给用户来操作，使得产品的创建更加简单灵活。



比如：比如麦当劳的套餐，服务员（具体建造者）可以随意搭配任意几种产品（零件）组成一款套餐（产品），然后出售给客户。步骤抽象如下:



1. 创建建造者定义麦当劳的产品
2. 创建服务员实现具体产品
3. 服务员随意搭配套餐出售给客户