# **核心概念**

**Topic**：消息主题，一级消息类型，生产者向其发送消息。**Message**：生产者向Topic发送并最终传送给消费者的数据消息的载体。

**消息属性**：生产者可以为消息定义的属性，包含Message Key和Tag。

**Message Key**：消息的业务标识，由消息生产者（Producer）设置，唯一标识某个业务逻辑。

**Message ID**：消息的全局唯一标识，由消息队列RocketMQ系统自动生成，唯一标识某条消息。

**Tag**：消息标签，二级消息类型，用来进一步区分某个Topic下的消息分类

**Producer**：也称为消息发布者，负责生产并发送消息至Topic。

**Consumer**：也称为消息订阅者，负责从Topic接收并消费消息。

**分区**：即Topic Partition，物理上的概念。每个Topic包含一个或多个分区。

**消费位点**：每个Topic会有多个分区，每个分区会统计当前消息的总条数，这个称为最大位点

MaxOffset；分区的起始位置对应的位置叫做起始位点MinOffset。

**Group**：一类生产者或消费者，这类生产者或消费者通常生产或消费同一类消息，且消息发布或订

阅的逻辑一致。

**Group ID**：Group的标识。

**队列**：个Topic下会由一到多个队列来存储消息。

**Exactly-Once****投递语义**：Exactly-Once投递语义是指发送到消息系统的消息只能被Consumer处理

且仅处理一次，即使Producer重试消息发送导致某消息重复投递，该消息在Consumer也只被消费

一次。

**集群消费**：一个Group ID所标识的所有Consumer平均分摊消费消息。例如某个Topic有9条消息，

一个Group ID有3个Consumer实例，那么在集群消费模式下每个实例平均分摊，只消费其中的3条

消息。

**广播消费**：一个Group ID所标识的所有Consumer都会各自消费某条消息一次。例如某个Topic有9

条消息，一个Group ID有3个Consumer实例，那么在广播消费模式下每个实例都会各自消费9条消

息。

**定时消息**：Producer将消息发送到消息队列RocketMQ服务端，但并不期望这条消息立马投递，而

是推迟到在当前时间点之后的某一个时间投递到Consumer进行消费，该消息即定时消息。

**延时消息**：Producer将消息发送到消息队列RocketMQ服务端，但并不期望这条消息立马投递，而

是延迟一定时间后才投递到Consumer进行消费，该消息即延时消息。

**事务消息**：RocketMQ提供类似X/Open XA的分布事务功能，通过消息队列RocketMQ的事务消息

能达到分布式事务的最终一致。

**顺序消息**：RocketMQ提供的一种按照顺序进行发布和消费的消息类型，分为全局顺序消息和分区

顺序消息。

**全局顺序消息**：对于指定的一个Topic，所有消息按照严格的先入先出（FIFO）的顺序进行发布和

消费。

**分区顺序消息**：对于指定的一个Topic，所有消息根据Sharding Key进行区块分区。同一个分区内

的消息按照严格的FIFO顺序进行发布和消费。Sharding Key是顺序消息中用来区分不同分区的关键

字段，和普通消息的Message Key是完全不同的概念。

**消息堆积**：Producer已经将消息发送到消息队列RocketMQ的服务端，但由于Consumer消费能力

有限，未能在短时间内将所有消息正确消费掉，此时在消息队列RocketMQ的服务端保存着未被消

费的消息，该状态即消息堆积。

**消息过滤**：Consumer可以根据消息标签（Tag）对消息进行过滤，确保Consumer最终只接收被

过滤后的消息类型。消息过滤在消息队列RocketMQ的服务端完成。

**消息轨迹**：在一条消息从Producer发出到Consumer消费处理过程中，由各个相关节点的时间、地

点等数据汇聚而成的完整链路信息。通过消息轨迹，您能清晰定位消息从Producer发出，经由消息

队列RocketMQ服务端，投递给Consumer的完整链路，方便定位排查问题。

**重置消费位点**：以时间轴为坐标，在消息持久化存储的时间范围内（默认3天），重新设置

Consumer对已订阅的Topic的消费进度，设置完成后Consumer将接收设定时间点之后由

Producer发送到消息队列RocketMQ服务端的消息。

**死信队列**：死信队列用于处理无法被正常消费的消息。当一条消息初次消费失败，消息队列

RocketMQ会自动进行消息重试；达到最大重试次数后，若消费依然失败，则表明Consumer在正

常情况下无法正确地消费该消息。此时，消息队列RocketMQ不会立刻将消息丢弃，而是将这条消

息发送到该Consumer对应的特殊队列中。消息队列RocketMQ将这种正常情况下无法被消费的消息称为死信消息（Dead-Letter

Message），将存储死信消息的特殊队列称为死信队列（Dead-Letter Queue）。

# **应用场景**

**削峰填谷**：诸如秒杀、抢红包、企业开门红等大型活动时皆会带来较高的流量脉冲，或因没做相应

的保护而导致系统超负荷甚至崩溃，或因限制太过导致请求大量失败而影响用户体验，消息队列

RocketMQ可提供削峰填谷的服务来解决该问题。

**异步解耦**：交易系统作为淘宝和天猫主站最核心的系统，每笔交易订单数据的产生会引起几百个下

游业务系统的关注，包括物流、购物车、积分、流计算分析等等，整体业务系统庞大而且复杂，消

息队列RocketMQ可实现异步通信和应用解耦，确保主站业务的连续性。

**顺序收发**：细数日常中需要保证顺序的应用场景非常多，例如证券交易过程时间优先原则，交易系

统中的订单创建、支付、退款等流程，航班中的旅客登机消息处理等等。与先进先出FIFO（First In

First Out）原理类似，消息队列RocketMQ提供的顺序消息即保证消息FIFO。

**分布式事务一致性**：交易系统、支付红包等场景需要确保数据的最终一致性，大量引入消息队列

RocketMQ的分布式事务，既可以实现系统之间的解耦，又可以保证最终的数据一致性。

**大数据分析**：数据在“流动”中产生价值，传统数据分析大多是基于批量计算模型，而无法做到实时

的数据分析，利用阿里云消息队列RocketMQ与流式计算引擎相结合，可以很方便的实现业务数据

的实时分析。

**分布式缓存同步**：天猫双11大促，各个分会场琳琅满目的商品需要实时感知价格变化，大量并发访

问数据库导致会场页面响应时间长，集中式缓存因带宽瓶颈，限制了商品变更的访问流量，通过消

息队列RocketMQ构建分布式缓存，实时通知商品数据的变化。



# 技术架构

![image-20220823220635455](https://xue-online.oss-cn-hangzhou.aliyuncs.com/uPic/20220823/1661263595_X5o9m9.png)

RocketMQ架构上主要分为四部分，如上图所示:

Producer：消息发布的角色，支持分布式集群方式部署。Producer通过MQ的负载均衡模块选择相

应的Broker集群队列进行消息投递，投递的过程支持快速失败并且低延迟。

Consumer：消息消费的角色，支持分布式集群方式部署。支持以push推，pull拉两种模式对消息

进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制，可以满足大多数用

户的需求。

NameServer：NameServer是一个非常简单的Topic路由注册中心，其角色类似Dubbo中的

zookeeper，支持Broker的动态注册与发现。主要包括两个功能：Broker管理，NameServer接受

Broker集群的注册信息并且保存下来作为路由信息的基本数据。然后提供心跳检测机制，检查

Broker是否还存活；路由信息管理，每个NameServer将保存关于Broker集群的整个路由信息和用

于客户端查询的队列信息。然后Producer和Conumser通过NameServer就可以知道整个Broker集

群的路由信息，从而进行消息的投递和消费。NameServer通常也是集群的方式部署，各实例间相

互不进行信息通讯。Broker是向每一台NameServer注册自己的路由信息，所以每一个

NameServer实例上面都保存一份完整的路由信息。当某个NameServer因某种原因下线了，

Broker仍然可以向其它NameServer同步其路由信息，Producer,Consumer仍然可以动态感知

Broker的路由的信息。

BrokerServer：Broker主要负责消息的存储、投递和查询以及服务高可用保证，为了实现这些功

能，Broker包含了以下几个重要子模块。

\1. Remoting Module：整个Broker的实体，负责处理来自clients端的请求。

\2. Client Manager：负责管理客户端(Producer/Consumer)和维护Consumer的Topic订阅信息

\3. Store Service：提供方便简单的API接口处理消息存储到物理硬盘和查询功能。

\4. HA Service：高可用服务，提供Master Broker 和 Slave Broker之间的数据同步功能。

\5. Index Service：根据特定的Message key对投递到Broker的消息进行索引服务，以提供消息

的快速查询。







# RocketMq的group,topic和tag三者的关系

在消息队列 RocketMQ 版中，Topic 与 Tag 都是业务上用来归类的标识，区分在于 Topic 是一级分类，而 Tag 可以理解为是二级分类。您可通过本文了解如何搭配使用 Topic 和 Tag 来实现消息过滤。

背景信息
Topic 和 Tag 的定义如下：

Topic

消息主题，通过 Topic 对不同的业务消息进行分类。

Tag

消息标签，用来进一步区分某个 Topic 下的消息分类，消息从生产者发出即带上的属性。

Topic 和 Tag 的关系如下图所示。

![mq中Topic和Tag的关系](https://xue-online.oss-cn-hangzhou.aliyuncs.com/uPic/20220824/1661304011_yjHElG.png)

适用场景
您可能会有这样的疑问：到底什么时候该用 Topic，什么时候该用 Tag？	

建议您从以下几个方面进行判断：

消息类型是否一致：如普通消息、事务消息、定时（延时）消息、顺序消息，不同的消息类型使用不同的 Topic，无法通过 Tag 进行区分。
业务是否相关联：没有直接关联的消息，如淘宝交易消息，京东物流消息使用不同的 Topic 进行区分；而同样是天猫交易消息，电器类订单、女装类订单、化妆品类订单的消息可以用 Tag 进行区分。
消息优先级是否一致：如同样是物流消息，盒马必须小时内送达，天猫超市 24 小时内送达，淘宝物流则相对会慢一些，不同优先级的消息用不同的 Topic 进行区分。
消息量级是否相当：有些业务消息虽然量小但是实时性要求高，如果跟某些万亿量级的消息使用同一个 Topic，则有可能会因为过长的等待时间而“饿死”，此时需要将不同量级的消息进行拆分，使用不同的 Topic。
总的来说，针对消息分类，您可以选择创建多个 Topic，或者在同一个 Topic 下创建多个 Tag。但通常情况下，不同的 Topic 之间的消息没有必然的联系，而 Tag 则用来区分同一个 Topic 下相互关联的消息，例如全集和子集的关系、流程先后的关系。

场景示例
以天猫交易平台为例，订单消息和支付消息属于不同业务类型的消息，分别创建 Topic_Order 和 Topic_Pay，其中订单消息根据商品品类以不同的 Tag 再进行细分，列如电器类、男装类、女装类、化妆品类等被各个不同的系统所接收。

通过合理的使用 Topic 和 Tag，可以让业务结构清晰，更可以提高效率。