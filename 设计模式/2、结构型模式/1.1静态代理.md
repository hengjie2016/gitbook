# 概念：

- 静态代理：代理类由程序员自己编写（代理类会对目标对象的特定方法进行增强）

# 思路：

- 1）：设计接口：原因：代理对象和目标对象都会实现同一个功能。
- 2）：编写目标对象（类）：实现接口。
- 3）：编写代理对象（类）：注入目标对象，调用其方法，最后增强方法。





# 角色分析：

1. 抽象的角色：一般用接口或者抽象类解决 - — 租房
2. 真实的角色：被代理的角色 —- 房东
3. 代理角色：代理真实角色，代理真实角色后，我们一般做一些附属操作 — 中介
4. 客户：访问代理对象的人 —我

![img](https://xue-online.oss-cn-hangzhou.aliyuncs.com/uPic/20220803/1659512790_6b5I7v.png) 

 ![img](https://xue-online.oss-cn-hangzhou.aliyuncs.com/uPic/20220803/1659512790_T7gwcZ.png)

# 静态代理的好处

- 可以使真实角色的操作更加纯粹！不用去关注一些公共的业务
- 公共的业务就交给代理角色！实现了业务的分工！
- 公共业务发生扩展的时候，方便集中管理





# 静态代理模式的缺点

每次编写一个目标类的时候，都需要重新编写多个代理类，很麻烦，有可能会出现错误。













什么是静态代理？
代理这个词是来源于Java设计模式中的代理模式，代理模式最简单的理解就是通过第三方来代理我们的工作

比如中介，房东需要将自己的房子租出去，而租客需要租房子，三者关系如此

租客租房子一般都找不到房东，房东也不会轻易将自己暴露给广大租客，因此就需要中介来充当这个中间关系

因此租客就只能通过中介来进行租房子这个工作，不需要通过房东，这就叫做代理----就是中介代理房东来处理租房子这件事情

那么我们应用于Java中又是什么样的情况呢？

首先创建一个主题接口（创建接口，JDK动态代理就是以接口、对象、代理对象为基础）

```
public interface UserDao(){
    void add();
}
```

然后创建该接口的实现类（真实主题），也称为被代理类（主要功能就在于该类中），我们需要一个代理类来代理这个类实现他的add方法

```
public class UserDaoImpl implements UserDao(){
    @Override
    public void add(){
        System.out.println("add.....");
    }
}
```

然后我们创建上述实现类的代理类（两个类需要实现共同的主题接口，这样才能对原有功能进行增强），使用代理类对原有类进行包装

```
public class UserDaoProxy implements UserDao{
    private UserDao target;
    public UserDaoProxy(UserDao target){
        this.target = target;
    }
    public void add(){
    System.out.println("before...");
    target.add();
    System.out.println("after...");
}
}
```




然后我们进行测试

```
@Test
    public void test1(){
       UserDao userDao = new UserDaoImpl();
       UserDaoProxy proxy = new UserDaoProxy(userDao);
       proxy.add();
    }
```

此图为结果输出

 ![img](https://xue-online.oss-cn-hangzhou.aliyuncs.com/uPic/20220803/1659516824_SU8Ty8.png)

 

可能有人会问，这样是不是多此一举，为什么要去代理呢，而且前两段代码就能实现的功能，为什么还需要一个代理类去代理它，这就涉及到我们的工作需求，在不改变实现类的情况下，对实现类进行功能的增加，而上述代码中两个输出语句就是对功能的增强（当然可以根据实际需求来添加实际代码），由此而产生了代理类，生成代理对象

而所谓的静态就是在创建代理类的时候，接口和被代理类都已经被固定了，无法改变，代理类就只能这一种类，我们主要的是实现代理功能，实际上已经完成了这个功能，

当实际开发中有很多这样的主题接口和类需要功能增强时，就需要更多的代理类，即每一个主题接口都得创建一个代理类，会造成代码的繁多和冗余，因此就产生了我们的动态代理技术